// Generated by the coevolve package
functions {
  // returns the Kronecker Product
  matrix kronecker_prod(matrix A, matrix B) {
    matrix[rows(A) * rows(B), cols(A) * cols(B)] C;
    int m;
    int n;
    int p;
    int q;
    m = rows(A);
    n = cols(A);
    p = rows(B);
    q = cols(B);
    for (i in 1:m)
      for (j in 1:n)
        for (k in 1:p)
          for (l in 1:q)
            C[p*(i-1)+k,q*(j-1)+l] = A[i,j]*B[k,l];
    return C;
  }
  
  // expected auto and cross effects over a discrete time t
  matrix A_dt(matrix A, real t) {
    return( matrix_exp(A * t) );
  }
  
  // calculate A sharp matrix
  matrix A_sharp(matrix A) {
    matrix[rows(A) * rows(A), cols(A) * cols(A)] A_temp;
    matrix[rows(A),cols(A)] I; // identity matrix
    I = diag_matrix(rep_vector(1,rows(A)));
    A_temp = kronecker_prod(A,I) + kronecker_prod(I,A);
    return(A_temp);
  }
  
  // solve SDE
  matrix cov_drift(matrix A, matrix Q, real ts) {
    matrix[rows(A) * rows(A), cols(A) * cols(A)] A_sharp_temp;
    matrix[rows(A) * rows(A), cols(A) * cols(A)] I; // identity matrix
    vector[rows(Q)*cols(Q)] row_Q;
    vector[rows(A)*cols(A)] irow_vec;
    matrix[rows(A),cols(A)] irow_mat;
    I = diag_matrix(rep_vector(1,rows(A_sharp_temp)));
    A_sharp_temp = A_sharp(A);
    // row operation takes elements of a matrix rowwise and puts them into a column vector
    for (i in 1:rows(Q))
      for (j in 1:cols(Q)) {
        row_Q[i + (j-1)*rows(Q)] = Q[j,i];
      }
    irow_vec = inverse(A_sharp_temp) * (matrix_exp(A_sharp_temp * ts) - I) * row_Q;
    // irow takes elements of a column vector and puts them in a matrix rowwise
    {
      int row_size = rows(A);
      int row_ticker = 1;
      int col_ticker = 0;
      for (i in 1:num_elements(irow_vec)) {
        col_ticker += 1;
        if (col_ticker > row_size) {
          row_ticker += 1;
          col_ticker = 1;
        }
        irow_mat[row_ticker,col_ticker] = irow_vec[i];
      }
    }
    return(irow_mat);
  }
}
data{
  int N; // number of taxa
  int J; // number of variables
  int N_seg; // number of segments in tree
  array[N_seg] int node_seq; // sequence of nodes
  array[N_seg] int parent; // parent node for each node
  array[N_seg] real ts; // amount of time since parent node
  array[N_seg] int tip; // is tip?
  array[J,J] int effects_mat; // which effects should be estimated?
  int num_effects; // number of effects being estimated
  array[N] real y1; // observed data variable 1
  array[N] real y2; // observed data variable 2
  int prior_only; // should the likelihood be ignored?
}
parameters{
  vector[num_effects] alpha_pars; // selection coefficients (actual parameters)
  vector<lower=0>[J] sigma; // drift scale
  vector[J] b; // SDE intercepts
  vector[J] eta_anc; // ancestral states
  matrix[N_seg - 1,J] z_drift; // stochastic drift, unscaled and uncorrelated
}
transformed parameters{
  matrix[N_seg,J] eta;
  matrix[J,J] Q;
  matrix[J,J] I;
  matrix[J,J] A;
  matrix[J,J] alpha;
  matrix[N_seg,J] drift_tips; // terminal drift parameters, saved here to use in likelihood for Gaussian outcomes
  matrix[N_seg,J] sigma_tips; // terminal drift parameters, saved here to use in likelihood for Gaussian outcomes
  // construct alpha matrix
  {
    int index;
    index = 1;
    for (i in 1:J) {
      for (j in 1:J) {
        if (effects_mat[i,j] == 1) {
          alpha[i,j] = alpha_pars[index];
          index += 1;
        } else if (effects_mat[i,j] == 0) {
          alpha[i,j] = 0;
        }
      }
    }
  }
  // calculate selection matrix
  for (j in 1:J) {
    for (i in 1:J) {
      if (i == j) {
        A[i,j] = -exp(alpha[i,j]); // autoregressive effects
      } else {
        A[i,j] = alpha[i,j]; // cross effects
      }
    }
  }
  // drift matrix
  Q = diag_matrix(square(sigma));
  // identity matrix
  I = diag_matrix(rep_vector(1,J));
  // setting ancestral states and placeholders
  for (j in 1:J) {
    eta[node_seq[1],j] = eta_anc[j];
    drift_tips[node_seq[1],j] = -99;
    sigma_tips[node_seq[1],j] = -99;
  }
  for (i in 2:N_seg) {
    matrix[J,J] A_delta; // amount of deterministic change (selection)
    matrix[J,J] VCV; // variance-covariance matrix of stochastic change (drift)
    vector[J] drift_seg; // accumulated drift over the segment
    A_delta = A_dt(A, ts[i]);
    VCV = cov_drift(A, Q, ts[i]);
    // no drift on the interaction, bc its simply a product of vars
    drift_seg = cholesky_decompose(VCV) * to_vector( z_drift[i-1,] );
    // if not a tip, add the drift parameter
    if (tip[i] == 0) {
      eta[node_seq[i],] = to_row_vector(
        A_delta * to_vector(eta[parent[i],]) + (inverse(A) * (A_delta - I) * b) + drift_seg
      );
      drift_tips[node_seq[i],] = to_row_vector(rep_vector(-99, J));
      sigma_tips[node_seq[i],] = to_row_vector(rep_vector(-99, J));
    }
    // if is a tip, omit, we'll deal with it in the model block;
    else {
      eta[node_seq[i],] = to_row_vector(
        A_delta * to_vector(eta[parent[i],]) + (inverse(A) * (A_delta - I) * b)
      );
      drift_tips[node_seq[i],] = to_row_vector(drift_seg);
      sigma_tips[node_seq[i],] = to_row_vector(sqrt(diagonal(Q)));
    }
  }
}
model{
  to_vector(alpha_pars) ~ std_normal();
  b ~ std_normal();
  sigma ~ std_normal();
  eta_anc ~ std_normal();
  to_vector(z_drift) ~ std_normal();
  if (!prior_only) {
    for (i in 1:N) {
        y1[i] ~ normal(eta[i,1], sigma_tips[i,1]);
        y2[i] ~ normal(eta[i,2], sigma_tips[i,2]);
    }
  }
}
